<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<meta name="description" content="A page used to calculate success odds of diving actions for the DIG 2.0 RP">
<meta name="keywords" content="Dig,RP,Diving,Spheres,Calculator">
<meta name="author" content="Parisbre56">

<title>DIG Diving Calculator</title>

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"/>
<link rel="icon" type="image/x-icon" href="/favicon.ico"/>
<style>
h2 {
}

ul {
	margin: 0;
}

.centerMe {
}

.button:hover {

}

#myId:hover {

}

#upperSpheres {
	background-color: LightGrey;
}
#middleSpheres {
	background-color: DarkGrey;
}
#lowerSpheres {
	background-color: Grey;
}

.col {
	background-color: White;
	position: absolute;
	transform: translate(-50%);
	width: 70px;
	height: 70px;
}

.textContainer {
	position: absolute;
	left: 50%;
	top: 50%;
	transform: translate(-50%,-50%);
}

.col1 {
	left: 16.66%;
}

.col2 {
	left: 33.33%;
}

.col3 {
	left: 50.00%;
}

.col4 {
	left: 66.66%;
}

.col5 {
	left: 83.33%;
}

.sphereRow {
	position: relative;
	height: 40px;
	width: 500px;
	margin: 10px;
}

.sphereSection {
	display: table;
}

#spheresContainer {
	position: absolute;
	left: 50%;
	transform: translate(-50%);
}

area {
	cursor: pointer;
}

span {
	vertical-align: top;
}

#mapInfoContainer {
	display: inline-block;
	vertical-align: top;
	max-width: 400px;
}

#sphereImage {
	display: inline-block;
}

#reinforcementList {
	display: inline-block;
	vertical-align: top;
}

#pop {
	float:right;
}
	
.pageInfo {
	font-size: 80%;
	opacity: 0.5;
}

div {
	max-width: 1000px;
}

body {
	max-width: 1000px;
}

</style>
<script>
//Sphere size in pixels
var sphereSize = 48;
var imageWidth = 400;
var imageHeight = 951;

var spheres = [
	["Ah",			{x: 200, y: 50, stat: null, links: [
										"Zon",
										"Xi",
										"Nehn"], desc: "Creation: Specifically the act of creating something out of nothing. This isn't the same as say, building something out of different pieces, or taking it from somewhere and bringing it here. It is literally pulling raw matter and energy from nothing. And as such, it is the highest form of the motive powers." }],
	["Zon",			{x: 125, y: 115, stat: null, links: [
										"Ah",
										"Xi",
										"Nehn",
										"Hel"], desc: "Duplication: The act of replicating or copying something that already exists. This new object is created out of nothing, much like with the above, but it is a copy of an existing thing, not a new creation in and of itself." }],
	["Xi",			{x: 275, y: 115, stat: null, links: [
										"Ah",
										"Zon",
										"Nehn",
										"Sige"], desc: "Summoning: The act of moving something from one place to another without traveling through the space between. Summoning brings something that already exists from one place to another, it doesn't create anything." }],
	["Nehn",		{x: 200, y: 190, stat: null, links: [
										"Ah",
										"Zon",
										"Xi",
										"Hel",
										"Sige",
										"Es"], desc: "Enchanting: Enchanting is, in this case the act of creating an active connection between the enchanted object and a sphere. This connection allows aspects of the sphere to manifest through the enchanted object. It is, in many ways, a lesser form of summoning, and carries with it many benefits and dangers, which are covered later." }],
	["Hel",			{x: 125, y: 265, stat: null, links: [
										"Zon",
										"Nehn",
										"Sige",
										"Es"], desc: "Transmutation: The act of changing the material or properties of something without altering its form." }],
	["Sige",		{x: 275, y: 265, stat: null, links: [
										"Xi",
										"Nehn",
										"Hel",
										"Es"], desc: "Alteration: The act of changing the form of something without altering its properties or material make up." }],
	["Es",			{x: 200, y: 340, stat: null, links: [
										"Nehn",
										"Hel",
										"Sige",
										"Telazch",
										"Yengenze",
										"Akhmah"], desc: "Manipulation: Moving or controlling something." }],
	["Telazch",		{x: 125, y: 405, stat: "Endurance", links: [
										"Es",
										"Yengenze",
										"Akhmah",
										"Tzimtzvot",
										"Noth"], desc: "Biology: Life in all forms, poison, healing, disease, animals, plants, etc." }],
	["Yengenze",	{x: 275, y: 405, stat: "Cunning", links: [
										"Es",
										"Telazch",
										"Akhmah",
										"Balarim",
										"Konis"], desc: "Mind: The mind, consciousness, and the spark of life. Perception, emotion, skills, thoughts, understanding, dreams, memories, etc." }],
	["Tzimtzvot",	{x: 50, y: 480, stat: "Strength", links: [
										"Telazch",
										"Akhmah",
										"Noth"], desc: "Elemental forces: Natural and elemental forces, electricity, light, kinetic energy, radiation, fire, etc." }],
	["Akhmah",		{x: 200, y: 480, stat: "Awareness", links: [
										"Es",
										"Telazch",
										"Yengenze",
										"Tzimtzvot",
										"Balarim",
										"Noth",
										"Konis",
										"Jal"], desc: "Mundane materials: natural, non-organic substances like chemical elements, water, stone, etc. Not things made by mankind or other sentient beings or living things." }],
	["Balarim",		{x: 350, y: 480, stat: "Knowledge", links: [
										"Yengenze",
										"Akhmah",
										"Konis"], desc: "Technology: Anything which is unnatural and created with purpose; writing, spoken language, technology, art, tools." }],
	["Noth",		{x: 125, y: 550, stat: "Dexterity", links: [
										"Telazch",
										"Tzimtzvot",
										"Akhmah",
										"Konis",
										"Jal"], desc: "Physics: Variables that describe the universe; size, speed, weight, spacial location, time, etc." }],
	["Konis",		{x: 275, y: 550, stat: "Speed", links: [
										"Yengenze",
										"Akhmah",
										"Balarim",
										"Noth",
										"Jal"], desc: "Weather and natural happenings: rain, snow, flooding, river flow, volcanoes, earthquakes, plate tectonics, oil deposit, tornados, etc." }],
	["Jal",			{x: 200, y: 625, stat: null, links: [
										"Akhmah",
										"Noth",
										"Konis",
										"Gesh",
										"Hal",
										"Undyne"], desc: "Shielding: The act of preventing something from entering an area; excluding and repelling it." }],
	["Gesh",		{x: 125, y: 690, stat: null, links: [
										"Jal",
										"Hal",
										"Undyne",
										"Non"], desc: "Binding: Binding is a very specific type of action and it only effects living or at least animate creatures. In essence, it is the act of forcing someone or something to something. For instance, you could bind someone to never tell anyone else a specific secret and, assuming they didn't have the will power to break it, the binding would prevent them from telling that secret. It can, however, be used to detect things as well, and be used as a sort of trip wire or trigger for certain events or circumstances. For instance, it could be used to detect someone's emotional state and cause some sort of reaction if it detects a particular emotion." }],
	["Hal",			{x: 275, y: 690, stat: null, links: [
										"Jal",
										"Gesh",
										"Undyne",
										"Neth"], desc: "Sealing: The act of preventing something from leaving a certain area; confining and trapping it." }],
	["Undyne",		{x: 200, y: 765, stat: null, links: [
										"Jal",
										"Gesh",
										"Hal",
										"Non",
										"Neth",
										"En"], desc: "Undo: The act of reverting something back to an older version of itself." }],
	["Non",			{x: 125, y: 840, stat: null, links: [
										"Gesh",
										"Undyne", 
										"Neth", 
										"En"], desc: "Dispelling: Because magic is everywhere and the connections to other spheres is not only what constitutes magic but also what allows things to have their current forms, dispelling is the act of severing connections to spheres outside the current one for a specific object or area. This is, in almost all cases, extremely destructive, as examination of what the Spheres of the Gray govern should tell you." }],
	["Neth",		{x: 275, y: 840, stat: null, links: [
										"Hal",
										"Undyne",
										"Non",
										"En"], desc: "Stasis: The act of keeping something in one particular state and not allowing it to change." }],
	["En",			{x: 200, y: 910, stat: null, links: [
										"Non",
										"Neth",
										"Undyne"], desc: "Destruction: This isn't destroying something like setting it on fire is destroying it or smashing it to pieces is destroying it. This is the act of erasing something from existence completely, including all pieces, and, in some cases, completely eradicating it from the memory and timeline of the world. This is the opposite of creation; Something into Nothing."}]
];
var sphereMap = new Map(spheres);

var selectedPath = ["Akhmah"];

var f = [];
function factorial (n) {
  if (n == 0 || n == 1)
    return 1;
  if (f[n] > 0)
    return f[n];
  return f[n] = factorial(n-1) * n;
}
//due to memoization following line will cache first 20 elements
factorial(20);

/* Reinitialize everything */
function reset() {
	selectedPath = ["Akhmah"];
	updatePage();
}

function getParameterByName(name, url) {
    if (!url) url = window.location.href;
	console.log("getParameterByName [name="+name+", url="+url+"]");
    name = name.replace(/[\[\]]/g, "\\$&");
    var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
        results = regex.exec(url);
    if (!results) return null;
    if (!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, " "));
}

var opacityColor = 0.65;
function colorValue(curr, min, max) {
	curr = curr - min;
	max = max - min;
	if(max == 0) {
		return "rgba(255, 0, 0, "+opacityColor+")";
	}
	if(curr/max < 0.5) {
		return "rgba(" + ((curr/max) * 255) + ", " + ((2*(curr/max)) * 255) + ", " + ((1 - (curr/max)) * 255) + ", "+opacityColor+")";
	} else {
		return "rgba(" + ((curr/max) * 255) + ", " + ((2-2*(curr/max)) * 255) + ", " + ((1 - (curr/max)) * 255) + ", "+opacityColor+")";
	}
}

/* Update the page with the current state */
function updatePage() {
	//Set share string
	console.log("updatePage [selectedPath=[" + selectedPath.toString() + "]]");
	var currUrl = window.location.href.substring(0, window.location.href.length-window.location.search.length);
	console.log("currUrl="+currUrl);
	var currPathChoices = selectedPath.slice(1, selectedPath.length);
	var currPathString = currPathChoices.toString();
	console.log("currPathChoices=["+currPathString+"]");
	var nerveStatValue = Number(document.getElementById("nerveStat").value);
	var sacrificeRecoupValue = Number(document.getElementById("sacrificeRecoup").value);
	var shareString = currUrl+"?path="+currPathString+"&nerve="+nerveStatValue+"&sacrificeRecoup="+sacrificeRecoupValue;
	if(document.getElementById("advantageState").checked) {
		shareString = shareString + "&state=adv";
	} else if (document.getElementById("disadvantageState").checked) {
		shareString = shareString + "&state=dis";
	}
	var shareStringElem = document.getElementById("shareString");
	shareStringElem.innerHTML=shareString;
	shareStringElem.href=shareString;
	
	//Set current path and reinforcements
	var currPathString = "";
	var prevSphere = "";
	var reinforcements = 0;
	var reinforcementListElem = document.getElementById("reinforcementList");
	reinforcementListElem.innerHTML=""; //Clear reinforcement list
	var updateSphereReinforcement = function() {
		if(currPathString.length > 1) {
			currPathString = currPathString + ", ";
		}
		currPathString = currPathString + prevSphere;
		if(reinforcements > 0) {
			currPathString = currPathString + " + " + reinforcements;
			
			//Add element to reinforcementList
			var li = document.createElement("li");
			li.innerHTML=prevSphere+": "+reinforcements;
			reinforcementListElem.appendChild(li);
		}
		
		//Reset for the next sphere
		prevSphere = currSphere;
		reinforcements = 0;
	};
	for(var pathIndex = 0; pathIndex < selectedPath.length; pathIndex++) {
		var currSphere = selectedPath[pathIndex];
		
		//If this is a reinforcement, add to the reinforcement count
		if(prevSphere === currSphere) {
			reinforcements++;
		} 
		//Else, add the previous sphere and reset for the next sphere
		else {
			updateSphereReinforcement();
		}
	}
	updateSphereReinforcement(); //We need a final update to clear the currently held value
	document.getElementById("currentPathString").innerHTML = currPathString;
	
	//Set nerve rolls
	document.getElementById("nerveRollsString").innerHTML = selectedPath.length + " (" + (selectedPath.length - 1) + " + 1)";
	
	var advantageValue = 0; //1 for advantage, -1 for disadvantage
	if(document.getElementById("advantageState").checked) {
		advantageValue = 1;
	} else if (document.getElementById("disadvantageState").checked) {
		advantageValue = -1;
	}
	console.log("computing odds of success [nerveStatValue="+nerveStatValue+", advantageValue="+advantageValue+", rolls="+selectedPath.length+", sacrificeRecoupValue="+sacrificeRecoupValue+"]");
	/*var insanityCalculationValue = computeInsanityChances(nerveStatValue, advantageValue, selectedPath.length, 0, sacrificeRecoupValue);
	document.getElementById("insanitySuccessOdds").innerHTML = (insanityCalculationValue.insanitySuccessOdds*100).toFixed(2) + "%";
	var averageNervePenaltyString = insanityCalculationValue.averageNervePenalty.toFixed(2);
	if(sacrificeRecoupValue > 0) {
		averageNervePenaltyString = averageNervePenaltyString + " (";
		averageNervePenaltyString = averageNervePenaltyString + Math.max(0, insanityCalculationValue.averageNervePenalty - sacrificeRecoupValue).toFixed(2);
		averageNervePenaltyString = averageNervePenaltyString + " with sacrifice recoup)";
	}
	document.getElementById("avgNervePenalty").innerHTML = averageNervePenaltyString;
	var maxNervePenaltyString = (selectedPath.length - 1).toFixed(2);
	if(sacrificeRecoupValue > 0) {
		maxNervePenaltyString = maxNervePenaltyString + " (";
		maxNervePenaltyString = maxNervePenaltyString + Math.max(0, selectedPath.length - 1 - sacrificeRecoupValue).toFixed(2);
		maxNervePenaltyString = maxNervePenaltyString + " with sacrifice recoup)";
	}
	document.getElementById("maxNervePenalty").innerHTML = maxNervePenaltyString;
	*/
	
	//Set calculation tables
	var probTable = document.getElementById("probTable");
	probTable.innerHTML = "<tr><th>Number of failures</th><th>Paths to this many failures</th><th>Chance of single path with this many failures</th><th>Chance of this many failures</th><th>Chance of success</th><th>Chance of success without recoup</th><th>Chance of getting this many failures and succeeding</th><th>Chance of getting this many failures and succeeding without recoup</th><th>Weighted nerve penalty</th><th>Weighted nerve penalty without recoup</th></tr>";
	var x = 0;
	var y = selectedPath.length - 1;
	var pathsToSuccessSingle = Math.min(19,Math.max(1,nerveStatValue-1));
	var chanceOfSuccessSingle;
	var chanceOfFailSingle;
	if(advantageValue > 0) {
		var temp = 20-pathsToSuccessSingle;
		temp = temp * temp;
		chanceOfSuccessSingle = (400-temp)/400;
		chanceOfFailSingle = temp/400;
	} else if (advantageValue < 0) {
		var temp = pathsToSuccessSingle*pathsToSuccessSingle;
		chanceOfSuccessSingle = temp/400;
		chanceOfFailSingle = (400-temp)/400;
	} else {
		chanceOfSuccessSingle = pathsToSuccessSingle/20;
		chanceOfFailSingle = (20-pathsToSuccessSingle)/20;
	}
	var totalSuccess = 0;
	var totalSuccessWithoutRecoup = 0;
	var totalNervePenalty = 0;
	var totalNervePenaltyWithoutRecoup = 0;
	var maxPaths = 0;
	var minPaths = null;
	var maxSingle = 0;
	var minSingle = null;
	var maxFailChance = 0;
	var minFailChance = null;
	var maxSuccess = 0;
	var minSuccess = null;
	var maxSuccessWithoutRecoup = 0;
	var minSuccessWithoutRecoup = null;
	var maxFailsAndSuccess = 0;
	var minFailsAndSuccess = null;
	var maxFailsAndSuccessWithoutRecoup = 0;
	var minFailsAndSuccessWithoutRecoup = null;
	var maxNerve = 0;
	var minNerve = null;
	var maxNerveWithoutRecoup = 0;
	var minNerveWithoutRecoup = null;
	for(x = 0; x <= y; x++) {
		var pathsWithXFails = factorial(y)/(factorial(x)*factorial(y-x));
		if(pathsWithXFails > maxPaths) {
			maxPaths = pathsWithXFails;
		}
		if(minPaths == null || pathsWithXFails < minPaths) {
			minPaths = pathsWithXFails;
		}
		var chanceOfPath = Math.pow(chanceOfFailSingle,x) * Math.pow(chanceOfSuccessSingle,y-x);
		if(chanceOfPath > maxSingle) {
			maxSingle = chanceOfPath;
		}
		if(minSingle == null || chanceOfPath < minSingle) {
			minSingle = chanceOfPath;
		}
		var chanceOfXFails = pathsWithXFails * chanceOfPath;
		if(chanceOfXFails > maxFailChance) {
			maxFailChance = chanceOfXFails;
		}
		if(minFailChance == null || chanceOfXFails < minFailChance) {
			minFailChance = chanceOfXFails;
		}
		var chanceOfXFailsSuccess = Math.min(19,Math.max(1,nerveStatValue-1-Math.max(0,x-sacrificeRecoupValue)))/20;
		if(chanceOfXFailsSuccess > maxSuccess) {
			maxSuccess = chanceOfXFailsSuccess;
		}
		if(minSuccess == null || chanceOfXFailsSuccess < minSuccess) {
			minSuccess = chanceOfXFailsSuccess;
		}
		var chanceOfXFailsSuccessWithoutRecoup = Math.min(19,Math.max(1,nerveStatValue-1-x))/20;
		if(chanceOfXFailsSuccessWithoutRecoup > maxSuccessWithoutRecoup) {
			maxSuccessWithoutRecoup = chanceOfXFailsSuccessWithoutRecoup;
		}
		if(minSuccessWithoutRecoup == null || chanceOfXFailsSuccessWithoutRecoup < minSuccessWithoutRecoup) {
			minSuccessWithoutRecoup = chanceOfXFailsSuccessWithoutRecoup;
		}
		var chanceOfXFailsAndSuccess = chanceOfXFails * chanceOfXFailsSuccess;
		if(chanceOfXFailsAndSuccess > maxFailsAndSuccess) {
			maxFailsAndSuccess = chanceOfXFailsAndSuccess;
		}
		if(minFailsAndSuccess == null || chanceOfXFailsAndSuccess < minFailsAndSuccess) {
			minFailsAndSuccess = chanceOfXFailsAndSuccess;
		}
		var chanceOfXFailsAndSuccessWithoutRecoup = chanceOfXFails * chanceOfXFailsSuccessWithoutRecoup;
		if(chanceOfXFailsAndSuccessWithoutRecoup > maxFailsAndSuccessWithoutRecoup) {
			maxFailsAndSuccessWithoutRecoup = chanceOfXFailsAndSuccessWithoutRecoup;
		}
		if(minFailsAndSuccessWithoutRecoup == null || chanceOfXFailsAndSuccessWithoutRecoup < minFailsAndSuccessWithoutRecoup) {
			minFailsAndSuccessWithoutRecoup = chanceOfXFailsAndSuccessWithoutRecoup;
		}
		var weightedNervePenalty = Math.max(0,x - sacrificeRecoupValue)*chanceOfXFails;
		if(weightedNervePenalty > maxNerve) {
			maxNerve = weightedNervePenalty;
		}
		if(minNerve == null || weightedNervePenalty < minNerve) {
			minNerve = weightedNervePenalty;
		}
		var weightedNervePenaltyWithoutRecoup = x*chanceOfXFails;
		if(weightedNervePenaltyWithoutRecoup > maxNerveWithoutRecoup) {
			maxNerveWithoutRecoup = weightedNervePenaltyWithoutRecoup;
		}
		if(minNerveWithoutRecoup == null || weightedNervePenaltyWithoutRecoup < minNerveWithoutRecoup) {
			minNerveWithoutRecoup = weightedNervePenaltyWithoutRecoup;
		}
	}
	//TODO add button to hide table? hide by default?
	for(x = 0; x <= y; x++) {
		var tr = document.createElement("tr");
		var td = document.createElement("th");
		td.innerHTML = x;
		td.style.backgroundColor = colorValue(x,0,y);
		tr.appendChild(td);
		
		//number of paths with x failures: (y!/(x!(y-x)!))
		var pathsWithXFails = factorial(y)/(factorial(x)*factorial(y-x));
		td = document.createElement("td");
		td.innerHTML = pathsWithXFails;
		td.style.backgroundColor = colorValue(pathsWithXFails,minPaths,maxPaths);
		tr.appendChild(td);
		
		//chance of getting a specific path (no advantage/disadvantage): (1-max(1,skill-1)/20)^x * (max(1,skill-1)/20)^(y-x)
		var chanceOfPath = Math.pow(chanceOfFailSingle,x) * Math.pow(chanceOfSuccessSingle,y-x);
		td = document.createElement("td");
		td.innerHTML = (chanceOfPath*100).toFixed(10) + "%";
		td.style.backgroundColor = colorValue(chanceOfPath,minSingle,maxSingle);
		tr.appendChild(td);
		
		//chance of getting a specific number of failures: (y!/(x!(y-x)!))*((1-max(1,skill-1)/20)^x * (max(1,skill-1)/20)^(y-x))
		var chanceOfXFails = pathsWithXFails * chanceOfPath;
		td = document.createElement("td");
		td.innerHTML = (chanceOfXFails*100).toFixed(10) + "%";
		td.style.backgroundColor = colorValue(chanceOfXFails,minFailChance,maxFailChance);
		tr.appendChild(td);
		
		//chance of succeeding with a certain number of failures: (max(1,skill-1-max(0,x-recoup))/20)
		var chanceOfXFailsSuccess = Math.min(19,Math.max(1,nerveStatValue-1-Math.max(0,x-sacrificeRecoupValue)))/20;
		td = document.createElement("td");
		td.innerHTML = (chanceOfXFailsSuccess*100).toFixed(10) + "%";
		td.style.backgroundColor = colorValue(chanceOfXFailsSuccess,minSuccess,maxSuccess);
		tr.appendChild(td);
		
		var chanceOfXFailsSuccessWithoutRecoup = Math.min(19,Math.max(1,nerveStatValue-1-x))/20;
		td = document.createElement("td");
		td.innerHTML = (chanceOfXFailsSuccessWithoutRecoup*100).toFixed(10) + "%";
		td.style.backgroundColor = colorValue(chanceOfXFailsSuccessWithoutRecoup,minSuccessWithoutRecoup,maxSuccessWithoutRecoup);
		tr.appendChild(td);
		
		//chance of getting a certain number of failures and succeeding: (y!/(x!(y-x)!))*((1-max(1,skill-1)/20)^x * (max(1,skill-1)/20)^(y-x))*(max(1,skill-1-max(0,x-recoup))/20)
		var chanceOfXFailsAndSuccess = chanceOfXFails * chanceOfXFailsSuccess;
		td = document.createElement("td");
		td.innerHTML = (chanceOfXFailsAndSuccess*100).toFixed(10) + "%";
		td.style.backgroundColor = colorValue(chanceOfXFailsAndSuccess,minFailsAndSuccess,maxFailsAndSuccess);
		tr.appendChild(td);
		
		var chanceOfXFailsAndSuccessWithoutRecoup = chanceOfXFails * chanceOfXFailsSuccessWithoutRecoup;
		td = document.createElement("td");
		td.innerHTML = (chanceOfXFailsAndSuccessWithoutRecoup*100).toFixed(10) + "%";
		td.style.backgroundColor = colorValue(chanceOfXFailsAndSuccessWithoutRecoup,minFailsAndSuccessWithoutRecoup,maxFailsAndSuccessWithoutRecoup);
		tr.appendChild(td);
		
		var weightedNervePenalty = Math.max(0,x - sacrificeRecoupValue)*chanceOfXFails;
		td = document.createElement("td");
		td.innerHTML = (weightedNervePenalty).toFixed(10);
		td.style.backgroundColor = colorValue(weightedNervePenalty,minNerve,maxNerve);
		tr.appendChild(td);
		
		var weightedNervePenaltyWithoutRecoup = x*chanceOfXFails;
		td = document.createElement("td");
		td.innerHTML = (weightedNervePenaltyWithoutRecoup).toFixed(10);
		td.style.backgroundColor = colorValue(weightedNervePenaltyWithoutRecoup,minNerveWithoutRecoup,maxNerveWithoutRecoup);
		tr.appendChild(td);
		
		totalSuccess += chanceOfXFailsAndSuccess;
		totalSuccessWithoutRecoup += chanceOfXFailsAndSuccessWithoutRecoup;
		totalNervePenalty += weightedNervePenalty;
		totalNervePenaltyWithoutRecoup += weightedNervePenaltyWithoutRecoup;
		probTable.appendChild(tr);
	}
	var totalTr = document.createElement("tr");
	var totalTd = document.createElement("th");
	totalTd.innerHTML = "TOTAL";
	totalTr.appendChild(totalTd);
	var totalTd = document.createElement("th");
	//all possible paths: 2^y
	totalTd.innerHTML = Math.pow(2,y);
	totalTr.appendChild(totalTd);
	var totalTd = document.createElement("th");
	totalTd.innerHTML = "-";
	totalTr.appendChild(totalTd);
	var totalTd = document.createElement("th");
	totalTd.innerHTML = "-";
	totalTr.appendChild(totalTd);
	var totalTd = document.createElement("th");
	totalTd.innerHTML = "-";
	totalTr.appendChild(totalTd);
	var totalTd = document.createElement("th");
	totalTd.innerHTML = "-";
	totalTr.appendChild(totalTd);
	var totalTd = document.createElement("th");
	totalTd.innerHTML = (totalSuccess*100).toFixed(10) + "%";
	totalTr.appendChild(totalTd);
	var totalTd = document.createElement("th");
	totalTd.innerHTML = (totalSuccessWithoutRecoup*100).toFixed(10) + "%";
	totalTr.appendChild(totalTd);
	var totalTd = document.createElement("th");
	totalTd.innerHTML = totalNervePenalty.toFixed(10);
	totalTr.appendChild(totalTd);
	var totalTd = document.createElement("th");
	totalTd.innerHTML = totalNervePenaltyWithoutRecoup.toFixed(10);
	totalTr.appendChild(totalTd);
	probTable.appendChild(totalTr);
	
	var insanitySuccessOddsString = (totalSuccess*100).toFixed(2) + "%";
	if(sacrificeRecoupValue > 0) {
		insanitySuccessOddsString = insanitySuccessOddsString + " (";
		insanitySuccessOddsString = insanitySuccessOddsString + (totalSuccessWithoutRecoup*100).toFixed(2);
		insanitySuccessOddsString = insanitySuccessOddsString + "% without sacrifice recoup)";
	}
	document.getElementById("insanitySuccessOdds").innerHTML = insanitySuccessOddsString;
	var averageNervePenaltyString = totalNervePenalty.toFixed(2);
	if(sacrificeRecoupValue > 0) {
		averageNervePenaltyString = averageNervePenaltyString + " (";
		averageNervePenaltyString = averageNervePenaltyString + totalNervePenaltyWithoutRecoup.toFixed(2);
		averageNervePenaltyString = averageNervePenaltyString + " without sacrifice recoup)";
	}
	document.getElementById("avgNervePenalty").innerHTML = averageNervePenaltyString;
	var maxNervePenaltyString = Math.max(0, selectedPath.length - 1 - sacrificeRecoupValue).toFixed(2);
	if(sacrificeRecoupValue > 0) {
		maxNervePenaltyString = maxNervePenaltyString + " (";
		maxNervePenaltyString = maxNervePenaltyString + (selectedPath.length - 1).toFixed(2);
		maxNervePenaltyString = maxNervePenaltyString + " without sacrifice recoup)";
	}
	document.getElementById("maxNervePenalty").innerHTML = maxNervePenaltyString;
	
	//TODO redraw path
}

function computeInsanityChances(nerveStatValue, advantageValue, pathLeft, fails, sacrificeRecoup) {
	var successOdds = nerveStatValue;
	//Recursion stop condition: reached the end of the path, so we need to reduce success odds by the number of fails so far
	if(pathLeft === 1 && fails > sacrificeRecoup) {
		successOdds = successOdds + sacrificeRecoup - fails;
	}
	
	//A 1 is considered an automatic success regardless of penalties, so there's always at least 1/20 chance of success
	if(successOdds < 2) {
		successOdds = 1;
	} 
	//A 20 is considered an automatic failure regardless of penaltiesm so there's always at most 19/20 chances of success
	else if(successOdds > 19) {
		successOdds = 19;
	}
	/* Else, remove one from the stat to get the chances of success. 
	 * This is roll under, which means that if we have
	 * a nerve stat of 3 we can only succeed on a roll of 1 or 2 -> 2/20
	 */
	else {
		successOdds = successOdds - 1;
	}
	var failOdds = 20 - successOdds;
	
	//Recursion stop condition: reached the end of the path, so just return the odds of the final roll
	if(pathLeft === 1) {
		//The final roll doesn't get a reroll, so no need to take advantage/disadvantage into account
		return {insanitySuccessOdds: successOdds/20, 
				//No nerve penalty for the final roll. The effects of failing it should be penalty enough
				averageNervePenalty: 0}
	}
	
	var totalOdds = 20;
	if(advantageValue>0) { //At advantage
		totalOdds = 400; //20*20
		failOdds = failOdds*failOdds;
		successOdds = totalOdds - failOdds;
	} else if(advantageValue<0) { //At disadvantage
		totalOdds = 400; //20*20
		successOdds = successOdds*successOdds;
		failOdds = totalOdds - successOdds;
	}
	var insanitySuccessCalculation = computeInsanityChances(nerveStatValue, advantageValue, pathLeft - 1, fails, sacrificeRecoup);
	var insanityFailureCalculation = computeInsanityChances(nerveStatValue, advantageValue, pathLeft - 1, fails+1, sacrificeRecoup);
	var insanitySuccessOdds = (successOdds * insanitySuccessCalculation.insanitySuccessOdds
			+ failOdds * insanityFailureCalculation.insanitySuccessOdds)/totalOdds;
	var averageNervePenalty = (failOdds/totalOdds) + 
			((successOdds * insanitySuccessCalculation.averageNervePenalty
			+ failOdds * insanityFailureCalculation.averageNervePenalty)/totalOdds);
	return {insanitySuccessOdds: insanitySuccessOdds, 
			averageNervePenalty: averageNervePenalty};
}

function computeInsanityChancesOld(nerveStatValue, advantageValue, pathLeft) {
	var successOdds = nerveStatValue;
	//A 1 is considered an automatic success regardless of penalties, so there's always at least 1/20 chance of success
	if(successOdds < 2) {
		successOdds = 1;
	} 
	//A 20 is considered an automatic failure regardless of penaltiesm so there's always at most 19/20 chances of success
	else if(successOdds > 19) {
		successOdds = 19;
	}
	/* Else, remove one from the stat to get the chances of success. 
	 * This is roll under, which means that if we have
	 * a nerve stat of 3 we can only succeed on a roll of 1 or 2 -> 2/20
	 */
	else {
		successOdds = successOdds - 1;
	}
	var failOdds = 20 - successOdds;
	
	//Recursion stop condition: reached the end of the path, so just return the odds of the final roll
	if(pathLeft === 1) {
		//The final roll doesn't get a reroll, so no need to take advantage/disadvantage into account
		return {insanitySuccessOdds: successOdds/20, 
				//No nerve penalty for the final roll. The effects of failing it should be penalty enough
				averageNervePenalty: 0}
	}
	
	var totalOdds = 20;
	if(advantageValue>0) { //At advantage
		totalOdds = 400; //20*20
		failOdds = failOdds*failOdds;
		successOdds = totalOdds - failOdds;
	} else if(advantageValue<0) { //At disadvantage
		totalOdds = 400; //20*20
		successOdds = successOdds*successOdds;
		failOdds = totalOdds - successOdds;
	}
	var insanitySuccessCalculation = computeInsanityChancesOld(nerveStatValue, advantageValue, pathLeft - 1);
	var insanityFailureCalculation = computeInsanityChancesOld(nerveStatValue-1, advantageValue, pathLeft - 1);
	var insanitySuccessOdds = (successOdds * insanitySuccessCalculation.insanitySuccessOdds
			+ failOdds * insanityFailureCalculation.insanitySuccessOdds)/totalOdds;
	var averageNervePenalty = (failOdds/totalOdds) + 
			((successOdds * insanitySuccessCalculation.averageNervePenalty
			+ failOdds * insanityFailureCalculation.averageNervePenalty)/totalOdds);
	return {insanitySuccessOdds: insanitySuccessOdds, 
			averageNervePenalty: averageNervePenalty};
}

function displaySphereInfo(sphereName) {
	console.log("displaySphereInfo [sphereName="+sphereName+"]");
	var sphereText = sphereName;
	var currSphere = sphereMap.get(sphereName);
	if(currSphere!=null) {
		if(currSphere.stat != null) {
			sphereText = sphereText + "\nStat: "+ currSphere.stat;
		}
		if(currSphere.desc != null) {
			sphereText = sphereText + "\n\nDesc: "+ currSphere.desc;
		}
	}
	alert(sphereText);
}

var lastClickStart = 0;
var pressed = false;
var pressTimer = null;
var longPressMillis = 1000;

/* Do any initial drawing necessary, create the map and load a path if necessary */
function drawValidateAndLoad() {
	//Create the onClicks for the image
	var map = document.getElementById("sphereMap");
	for(var sphereIndex = 0; sphereIndex < spheres.length; sphereIndex++) {
		var sphereName = spheres[sphereIndex][0]
		console.log("Adding "+sphereName);
		var currSphere = spheres[sphereIndex][1];
		var currArea = document.createElement("area");
		currArea.id=sphereName;
		currArea.shape="circle";
		currArea.coords=currSphere.x+","+currSphere.y+","+sphereSize;
		currArea.alt=sphereName;
		var downFun =function(e) {
			var isRightMB = false;
			e = e || window.event;

			if ("which" in e) { // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
				isRightMB = e.which == 3;
			}
			else if ("button" in e) {  // IE, Opera
				isRightMB = e.button == 2;
			}
			if(isRightMB) {
				console.log("Ignoring right click");
				return false;
			}
			if(e != null && typeof e.preventDefault === 'function') {
				console.log("Called preventDefault");
				e.preventDefault();
			}
			if(e != null && typeof e.stopPropagation === 'function') {
				console.log("Called stopPropagation");
				e.stopPropagation();
			}

			//Else, if this is not a right click
			var id = this.id;
			lastClickStart = new Date().getTime();
			pressed = true;
			console.log("Mouse Down [id="+id+", lastClickStart="+lastClickStart+", pressed="+pressed+"]");
			pressTimer = window.setTimeout(function() {
					var currTime = new Date().getTime();
					var passedTime = currTime - lastClickStart;
					console.log("Timeout Triggered [id="+id+", lastClickStart="+lastClickStart+", currTime="+currTime+", passedTime="+passedTime+", pressed="+pressed+"]");
					displaySphereInfo(id);
				}, longPressMillis);
			return false;
		};
		currArea.onmousedown = downFun;
		//currArea.ontouchstart = downFun;
		var upFun=function() {
			clearTimeout(pressTimer);
			var currTime = new Date().getTime();
			var passedTime = currTime - lastClickStart;
			pressed = false;
			console.log("Mouse Up [id="+this.id+", currTime="+currTime+", passedTime="+passedTime+", pressed="+pressed+"]");
			if(passedTime < longPressMillis) {
				addSphereToPath(this.id);
			}
			return false;
		};
		currArea.onmouseup = upFun;
		//currArea.ontouchend = upFun;
		var cancelFun=function() {
			clearTimeout(pressTimer);
			var currTime = new Date().getTime();
			var passedTime = currTime - lastClickStart;
			pressed = false;
			console.log("Mouse Up [id="+this.id+", currTime="+currTime+", passedTime="+passedTime+", pressed="+pressed+"]");
			return false;
		};
		//currArea.ontouchmove=cancelFun;
		//currArea.ontouchcancel=cancelFun;
		currArea.oncontextmenu=function(e) {
			e = e || window.event;
			if(e != null && typeof e.preventDefault === 'function') {
				console.log("Called preventDefault");
				e.preventDefault();
			}
			if(e != null && typeof e.stopPropagation === 'function') {
				console.log("Called stopPropagation");
				e.stopPropagation();
			}
			displaySphereInfo(this.id);
			return false;
		}
		
		map.appendChild(currArea);
	}
	
	var loadString = getParameterByName("path");
	console.log("Loading path [loadString="+loadString+"]");
	if(loadString != null && loadString.length > 1) {
		var splitLoadString = loadString.split(",");
		console.log("Loading split path [splitLoadString.length="+splitLoadString.length+", splitLoadString=["+splitLoadString+"]]");
		for(var loadIndex=0; loadIndex < splitLoadString.length; loadIndex++) {
			var toLoad = splitLoadString[loadIndex];
			console.log("Loading [toLoad="+toLoad+"]");
			if(!(addSphereToPath(toLoad) === true)) {
				alert("Load failed!\nOnly "+loadIndex+" out of "+splitLoadString.length+" steps loaded.")
				break;
			}
		}
	}
	
	//Load the nerve value
	var loadNerveValue = getParameterByName("nerve");
	console.log("loadNerveValue="+loadNerveValue);
	if(loadNerveValue != null) {
		loadNerveValue = Number(loadNerveValue);
		loadNerveValue = Math.floor(loadNerveValue);
		console.log("finalLoadNerveValue="+loadNerveValue);
		document.getElementById("nerveStat").value = loadNerveValue;
	} else {
		document.getElementById("nerveStat").value = 10;
	}
	
	//Load the sacrificeRecoup value
	var loadSacrificeRecoupValue = getParameterByName("sacrificeRecoup");
	console.log("loadSacrificeRecoupValue="+loadSacrificeRecoupValue);
	if(loadSacrificeRecoupValue != null) {
		loadSacrificeRecoupValue = Number(loadSacrificeRecoupValue)
		loadSacrificeRecoupValue = Math.floor(loadSacrificeRecoupValue)
		console.log("finalLoadSacrificeRecoupValue="+loadSacrificeRecoupValue);
		document.getElementById("sacrificeRecoup").value = loadSacrificeRecoupValue;
	} else {
		document.getElementById("sacrificeRecoup").value = 0;
	}
	
	//Load the state value
	var loadStateValue = getParameterByName("state");
	console.log("loadStateValue="+loadStateValue);
	if(loadStateValue != null) {
		if(loadStateValue === "adv") {
			console.log("state advantage");
			document.getElementById("advantageState").checked = true;
		} else if (loadStateValue === "dis") {
			console.log("state disadvantage");
			document.getElementById("disadvantageState").checked = true;
		} else {
			console.log("ignoring state");
		}
	}
	
	updatePage();
}

//Attempt to add a sphere to the path. Return true for success, false for failure
function addSphereToPath(selectedSphereName) {
	console.log("addSphereToPath [selectedSphereName="+selectedSphereName+"]");
	var currSphereName = selectedPath[selectedPath.length - 1];
	console.log("currSphereName="+currSphereName);
	
	//If we are reinforcing a sphere, simply add it to the path
	if(selectedSphereName === currSphereName) {
		selectedPath.push(selectedSphereName)
		
		updatePage();
		return true;
	}
	
	//If we are adding a new sphere and there is a link from the current sphere to the new one, simply add it to the path
	var currSphere = sphereMap.get(currSphereName);
	if(currSphere.links.includes(selectedSphereName)) { 
		selectedPath.push(selectedSphereName)
		
		updatePage();
		return true;
	}
	
	//Else, display error
	alert("Invalid selection!\n"+
			"You can't go from "+currSphereName+" to "+selectedSphereName+".\n\n"+
			"Possible choices: "+currSphere.links.toString());
	return false;
}

function popLastSphere() {
	console.log("Pop last sphere");
	if(selectedPath.length <= 1) {
		console.log("Already at the begining, nothing to pop");
		return;
	}
	console.log("Popped: " + selectedPath.pop());
	updatePage();
}

</script>
</head>
<body onload="drawValidateAndLoad()">
	<noscript><span style="color: red; font-size: 300%;">This page requires JavaScript to work properly</span></noscript>
	<div><input id="reset" name="reset" type="button" value="Reset" onclick="reset()"/></div>
	<div>Click the spheres to select them. Clicking a sphere again reinforces it. Long click or right click to display detailed information.</div>
	<div>	
		<img id="sphereImage" src="spheres.png" alt="Spheres" usemap="#sphereMap">

		<map id="sphereMap" name="sphereMap">
		</map>
		
		<form id="mapInfoContainer">
			<div><b>Current Path:</b> <span id="currentPathString"></span> <input id="pop" name="pop" type="button" value="Remove Last Sphere" onclick="popLastSphere()"/> </div>
			<div><b>Nerve Rolls:</b> <span id="nerveRollsString"></span></div>
			<div><b>Nerve Stat:</b> <input id="nerveStat" name="nerveStat" type="number" step="1" required="true" oninput="updatePage()" /></div>
			<div><b>Sacrifice Recoup:</b> <input id="sacrificeRecoup" name="sacrificeRecoup" type="number" step="1" min="0" required="true" oninput="updatePage()" /></div>
			<div><b>State:</b> 
				<input id="advantageState" name="state" type="radio" required="true" oninput="updatePage()" /><label for="advantageState">Advantage</label>
				<input id="normalState" name="state" type="radio" required="true" oninput="updatePage()" checked /><label for="normalState">Normal</label>
				<input id="disadvantageState" name="state" type="radio" required="true" oninput="updatePage()" /><label for="disadvantageState">Disadvantage</label>
			</div>
			<div><b>Insanity Roll Success Odds:</b> <span id="insanitySuccessOdds"></span></div>
			<div><b>Average Nerve Penalty:</b> <span id="avgNervePenalty"></span></div>
			<div><b>Maximum Nerve Penalty:</b> <span id="maxNervePenalty"></span></div>
			<div><b>Reinforcements:</b> <ul id="reinforcementList"></ul></div>
		</form>
		<div><b>Share Link:</b> <a id="shareString" target="_blank" href=""></a></div>
	</div>
	<div>
		<table id="probTable">
		</table>
	</div>
	<div class="pageInfo">Page hosted on github, find the source code here: <a target="_blank" href="https://github.com/parisbre56/parisbre56.github.io/blob/master/spheres.html">https://github.com/parisbre56/parisbre56.github.io/blob/master/spheres.html</a></div>
</body>
